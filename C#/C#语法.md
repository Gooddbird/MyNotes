# C#

C#程序在 .NET 平台上运行。

## .NET
.NET是 公共语言运行时(CLR)的虚执行系统和一组统一的类库。

CLR 是 Microsoft 对公共语言基础结构 (CLI) 国际标准的商业实现。

CLI 是创建执行和开发环境的基础，语言和库可以在其中无缝地协同工作。

C# 编写的源代码被编译成符合 CLI 规范的中间语言 (IL)。 IL 代码和资源（如位图和字符串）存储在程序集中，扩展名通常为 .dll。 程序集包含一个介绍程序集的类型、版本和区域性的清单。

执行 C# 程序时，程序集将加载到 CLR。 CLR 会直接执行实时 (JIT) 编译，将 IL 代码转换成本机指令。 CLR 可提供其他与自动垃圾回收、异常处理和资源管理相关的服务。 CLR 执行的代码有时称为“托管代码”（而不是“非托管代码”），被编译成面向特定系统的本机语言。

语言互操作性是 .NET 的一项重要功能。 C# 编译器生成的 IL 代码符合公共类型规范 (CTS)。 通过 C# 生成的 IL 代码可以与通过 .NET 版本的 F#、Visual Basic、C++ 或其他 20 多种与 CTS 兼容的任何语言所生成的代码进行交互。 一个程序集可能包含多个用不同 .NET 语言编写的模块，且类型可以相互引用，就像是用同一种语言编写的一样。

除了运行时服务之外，.NET 还包含大量库。 这些库支持多种不同的工作负载。 它们已整理到命名空间中，这些命名空间提供各种实用功能，包括文件输入输出、字符串控制、XML 分析、Web 应用程序框架和 Windows 窗体控件。


## C#简介

C#不仅面向对象，而且类型安全。包含一些功能如：垃圾回收会自动回收无法访问的未使用对象所占用的内存。 异常处理提供了一种结构化且可扩展的方法来进行错误检测和恢复。 Lambda 表达式支持函数编程技术。

C# 采用统一的类型系统。 所有 C# 类型（包括 int 和 double 等基元类型）均继承自一个根 object 类型。 所有类型共用一组通用运算。 任何类型的值都可以一致地进行存储、传输和处理。

```
using System;

class Hello {
    
    static void Main(string[] args) {
        Console.WriteLine("Hello c#");
    }
};

```
Hello 类只有一个成员，即 Main 方法。 Main 方法使用 static 修饰符进行声明。 实例方法可以使用关键字 this 引用特定的封闭对象实例，而静态方法则可以在不引用特定对象的情况下运行。 按照约定，Main 静态方法是 C# 程序的入口点。

c#有两种类型：值类型 和 引用类型

值类型的变量直接包含数据，而引用类型的变量则存储对数据（称为“对象”）的引用。 借助值类型，每个变量都有自己的数据副本；

引用类型，两个变量可以引用同一个对象；对一个变量执行的运算可能会影响另一个变量引用的对象。 因此，对一个变量执行的运算不会影响另一个变量（ref 和 out 参数变量除外）。

标识符为变量名称。 标识符是不包含任何空格的 unicode 字符序列。 如果标识符的前缀为 @，则该标识符可以是 C# 保留字。 这在与其他语言交互时非常有用。

C# 程序可以存储在多个源文件中。 在编译 C# 程序时，将同时处理所有源文件，并且源文件可以自由地相互引用。 从概念上讲，就好像所有源文件在被处理之前都连接到一个大文件。 在 C# 中永远都不需要使用前向声明，因为声明顺序无关紧要（极少数例外情况除外）。 C# 并不限制源文件只能声明一种公共类型，也不要求源文件的文件名必须与其中声明的类型相匹配。

c# 类型如下：
- 值类型
  - 简单类型
    - 有符号整数 int long short sbyte
    - 无符号整数 byte ushort uint ulong
    - Unicode字符 char
    - 浮点 double float
    - 高精度十进制浮点 decimal
    - 布尔 bool (true or flase)
  - 枚举类型 enum
  - 结构体类型 struct
  - **可以为null的值类型**
  - 元组 (T1, T2, T3....)
- 引用类型
  - 类类型
    - 所有类型的基类 object
    - 字符串 string
    - class C {...}
  - 接口类型
    - interface I {...}
  - 数组
    - int[] int[][]
  - 委托类型 
    - delegate

**可以为null的类型**不需要单独定义。对于所有不可以为 null 的类型 T，都有对应的可以为 null 的类型 T?，后者可以包含附加值 null。 例如，int? 是可保存任何 32 位整数或 null 值的类型，string? 是可以保存任何 string 或 null 值的类型。

C# 采用统一的类型系统，因此任意类型的值都可视为 object。 每种 C# 类型都直接或间接地派生自 object 类类型，而 object 是所有类型的最终基类。 只需将值视为类型 object，即可将引用类型的值视为对象。 通过执行装箱和取消装箱操作，可以将值类型的值视为对象。 在以下示例中，int 值被转换成 object，然后又恢复成 int。
```
int i = 123;
object o = i; // 装箱
int j = (int)o; // 卸箱
```
将值类型的值分配给 object 对象引用时，会分配一个“箱”来保存此值。 该箱是引用类型的实例，此值会被复制到该箱。 相反，当 object 引用被显式转换成值类型时，将检查引用的 object 是否是具有正确值类型的箱。 如果检查成功，则会将箱中的值复制到值类型。 

## c#程序构建

### 成员
class的成员，要么是 实例成员， 要么是静态成员（static修饰）。静态成员属于类，实例成员属于对象。

成员类型如下：字段、方法、属性、索引器、事件、运算符、构造函数、终结器、类型

#### 方法
当方法主体为单个表达式时候，可以简写 如：
```
public string ToString() => "This is string";
```
##### 参数传递
包含值参数、引用参数、输出参数和参数数组

引用参数用于按引用传递自变量。 为引用参数传递的自变量必须是一个带有明确值的变量。 在方法执行期间，引用参数指出的存储位置与自变量相同。 引用参数使用 ref 修饰符进行声明。

```
static void Swap(ref int x, ref int y)
{
    int temp = x;
    x = y;
    y = temp;
}

public static void SwapExample()
{
    int i = 1, j = 2;
    Swap(ref i, ref j);
    Console.WriteLine($"{i} {j}");    // "2 1"
}
```
输出参数用于按引用传递自变量。 输出参数与引用参数类似，不同之处在于，不要求向调用方提供的自变量显式赋值。 输出参数使用 out 修饰符进行声明。
```
static void Divide(int x, int y, out int result, out int remainder)
{
    result = x / y;
    remainder = x % y;
}

public static void OutUsage()
{
    Divide(10, 3, out int res, out int rem);
    Console.WriteLine($"{res} {rem}");	// "3 1"
}
```
参数数组 允许向方法传递数量不定的自变量。 参数数组使用 params 修饰符进行声明。 参数数组只能是方法的最后一个参数，且参数数组的类型必须是一维数组类型。在调用包含形参数组的方法时，要么可以传递形参数组类型的一个实参，要么可以传递形参数组的元素类型的任意数量实参。 在后一种情况中，数组实例会自动创建，并初始化为包含给定的自变量。
```
public class Console
{
    public static void Write(string fmt, params object[] args) { }
    public static void WriteLine(string fmt, params object[] args) { }
    // ...
}
```
### 属性
属性 是字段的自然扩展。 两者都是包含关联类型的已命名成员，用于访问字段和属性的语法也是一样的。 不过，与字段不同的是，属性不指明存储位置。 相反，属性包含访问器，用于指定在读取或写入属性值时执行的语句。属性的声明方式与字段相似，区别是属性声明以在分隔符 { 和 } 之间写入的 get 访问器或 set 访问器结束，而不是以分号结束。 同时包含 get 访问器和 set 访问器的属性是 读写属性，仅包含 get 访问器的属性是 只读属性，仅包含 set 访问器的属性是 只写属性。

## c#字符串内插
C# 字符串内插使你能够通过定义表达式（其结果放置在格式字符串中）来设置字符串格式。 
```
Console.WriteLine($"The low and high temperature on {weatherData.Date:MM-DD-YYYY}");
```